---
description: RFC 1372 - Telnet远程流控制选项，由C. Hedrick和D. Borman于1992年10月发布，是RFC 1080的扩展版本，增加了RESTART-ANY和RESTART-XON子选项，提供了更灵活的流控制恢复机制，允许使用任意字符或仅XON字符来恢复输出
keywords:
  - RFC1372
  - Telnet
  - 远程流控制
  - Remote Flow Control
  - RESTART-ANY
  - RESTART-XON
  - XON
  - XOFF
  - 流控制
  - 终端控制
  - 软件流控制
  - Control-S
  - Control-Q
  - 终端协议
  - 远程登录
  - 协议选项
  - 网络协议
  - 流量控制
  - IAC
  - Telnet选项
properties:
  rfc_number: 1372
  title: "Telnet Remote Flow Control Option"
  authors:
    - name: "C. Hedrick"
      organization: "Rutgers University"
    - name: "D. Borman"
      organization: "Cray Research, Inc."
  publication_date: "1992-10"
  status: "标准跟踪协议"
  category: "Telnet协议扩展"
  obsoletes: "RFC 1080"
  related_rfc:
    - "RFC 854"
    - "RFC 1080"
---
# RFC 1372 - Telnet远程流控制选项

## 文档概述

RFC 1372是由Rutgers大学的C. Hedrick和Cray Research公司的D. Borman于1992年10月联合发布的Telnet协议扩展文档，标题为"Telnet Remote Flow Control Option"（Telnet远程流控制选项）。该文档是RFC 1080的扩展和改进版本，正式取代了RFC 1080。

RFC 1372在保留RFC 1080核心功能的基础上，增加了两个重要的子选项：RESTART-ANY和RESTART-XON。这些新增功能提供了更精细的流控制管理能力，允许应用程序指定在流控制暂停后如何恢复输出，从而解决了RFC 1080在实际应用中暴露出的一些局限性。

## 历史背景

### RFC 1080的局限性

RFC 1080在1988年发布后，在Unix系统和学术机构中得到了广泛应用。然而，在实际使用过程中，用户和开发者发现了一些问题：

1. **恢复机制单一**：RFC 1080只提供了简单的开关控制（ON/OFF），但没有定义如何恢复被暂停的输出。在传统的XON/XOFF流控制中，只有XON字符（Control-Q）可以恢复输出，但这种限制在某些场景下不够灵活。

2. **用户体验问题**：当用户意外按下Control-S（XOFF）导致输出暂停时，必须记住按Control-Q才能恢复。对于不熟悉流控制机制的用户，这可能导致困惑，他们可能会尝试按其他键来"唤醒"终端。

3. **应用程序需求多样化**：不同的应用程序对流控制恢复机制有不同的需求。有些应用希望严格遵循XON/XOFF协议，而有些应用则希望任意按键都能恢复输出，以提供更好的用户体验。

### RFC 1372的设计动机

RFC 1372的开发是为了解决这些实际问题，主要设计动机包括：

1. **增强灵活性**：提供多种流控制恢复模式，让应用程序根据自身需求选择合适的机制

2. **改善用户体验**：允许使用任意字符恢复输出，减少用户困惑

3. **保持兼容性**：在扩展功能的同时，确保与RFC 1080的向后兼容

4. **标准化实践**：将一些已经在实际系统中使用的非标准扩展纳入正式标准

## 技术规范

### 选项代码

RFC 1372继续使用RFC 1080定义的选项代码：

```
TOGGLE-FLOW-CONTROL = 33
```

### 命令代码

RFC 1372定义了以下命令代码：

```
OFF         = 0
ON          = 1
RESTART-ANY = 2
RESTART-XON = 3
```

### 命令格式

**选项协商**：
```
IAC WILL TOGGLE-FLOW-CONTROL
IAC DO TOGGLE-FLOW-CONTROL
IAC WONT TOGGLE-FLOW-CONTROL
IAC DONT TOGGLE-FLOW-CONTROL
```

**子选项命令**：
```
IAC SB TOGGLE-FLOW-CONTROL OFF IAC SE
IAC SB TOGGLE-FLOW-CONTROL ON IAC SE
IAC SB TOGGLE-FLOW-CONTROL RESTART-ANY IAC SE
IAC SB TOGGLE-FLOW-CONTROL RESTART-XON IAC SE
```

### 命令语义

#### OFF命令

```
IAC SB TOGGLE-FLOW-CONTROL OFF IAC SE
```

发送方请求接收方禁用流控制。当接收方收到此命令后，应停止对XON/XOFF字符的特殊处理，将它们作为普通数据传递给应用程序。

**使用场景**：
- 用户启动需要使用Control-S和Control-Q作为命令键的应用程序（如Emacs编辑器）
- 全屏应用程序不需要流控制功能
- 应用程序有自己的屏幕刷新控制机制

#### ON命令

```
IAC SB TOGGLE-FLOW-CONTROL ON IAC SE
```

发送方请求接收方启用流控制。当接收方收到此命令后，应开始对XON/XOFF字符进行特殊处理，用于控制数据流。

**使用场景**：
- 用户退出编辑器，恢复正常的流控制功能
- 需要查看大量输出时，允许用户暂停和恢复显示
- 恢复终端的默认行为

#### RESTART-ANY命令

```
IAC SB TOGGLE-FLOW-CONTROL RESTART-ANY IAC SE
```

发送方请求接收方在流控制启用时，允许使用**任意字符**（除了另一个XOFF字符）来恢复输出。

**工作原理**：
1. 当用户按下Control-S（XOFF）时，输出暂停
2. 用户按下任意其他键（除了再次按Control-S），输出恢复
3. 用于恢复输出的字符会被"消耗"，不会传递给应用程序

**优势**：
- 提供更直观的用户体验
- 用户不需要记住特定的恢复键
- 减少因不知道如何恢复而导致的困惑

**注意事项**：
- 用于恢复的字符会丢失，不会被应用程序接收
- 可能不适合需要严格遵循XON/XOFF协议的应用

#### RESTART-XON命令

```
IAC SB TOGGLE-FLOW-CONTROL RESTART-XON IAC SE
```

发送方请求接收方在流控制启用时，**仅允许XON字符**（Control-Q）来恢复输出。

**工作原理**：
1. 当用户按下Control-S（XOFF）时，输出暂停
2. 只有当用户按下Control-Q（XON）时，输出才会恢复
3. 在暂停期间按下的其他字符会被正常传递给应用程序

**优势**：
- 严格遵循传统的XON/XOFF协议
- 不会丢失用户输入的字符
- 适合需要精确流控制的应用

**使用场景**：
- 需要严格协议遵从的系统
- 应用程序需要接收所有用户输入
- 与传统系统的兼容性要求

### 协议交互流程

#### 初始协商

**服务器发起协商**：
```
服务器 -> 客户端: IAC WILL TOGGLE-FLOW-CONTROL
客户端 -> 服务器: IAC DO TOGGLE-FLOW-CONTROL
```

**客户端发起协商**：
```
客户端 -> 服务器: IAC DO TOGGLE-FLOW-CONTROL
服务器 -> 客户端: IAC WILL TOGGLE-FLOW-CONTROL
```

**拒绝协商**：
```
服务器 -> 客户端: IAC WILL TOGGLE-FLOW-CONTROL
客户端 -> 服务器: IAC DONT TOGGLE-FLOW-CONTROL
```

#### 流控制状态管理

**场景1：启动编辑器时禁用流控制**
```
1. 用户启动Emacs编辑器
2. 服务器 -> 客户端: IAC SB TOGGLE-FLOW-CONTROL OFF IAC SE
3. 客户端禁用流控制，Control-S和Control-Q作为普通字符传递
4. 用户可以正常使用Emacs的搜索功能（Control-S）
```

**场景2：设置RESTART-ANY模式**
```
1. 服务器 -> 客户端: IAC SB TOGGLE-FLOW-CONTROL ON IAC SE
2. 服务器 -> 客户端: IAC SB TOGGLE-FLOW-CONTROL RESTART-ANY IAC SE
3. 用户按Control-S暂停输出
4. 用户按任意键（如空格键）恢复输出
5. 用于恢复的字符被消耗，不传递给应用
```

**场景3：设置RESTART-XON模式**
```
1. 服务器 -> 客户端: IAC SB TOGGLE-FLOW-CONTROL ON IAC SE
2. 服务器 -> 客户端: IAC SB TOGGLE-FLOW-CONTROL RESTART-XON IAC SE
3. 用户按Control-S暂停输出
4. 用户按其他键，字符被传递给应用但输出仍暂停
5. 用户按Control-Q，输出恢复
```

### 默认行为

RFC 1372定义的默认行为为：
```
WONT TOGGLE-FLOW-CONTROL
DONT TOGGLE-FLOW-CONTROL
```

这意味着在没有明确协商的情况下，双方都不使用此选项，流控制行为由本地系统决定。

## 与RFC 1080的区别

### 主要改进

1. **新增RESTART-ANY子选项**
   - RFC 1080：无此功能
   - RFC 1372：允许任意字符恢复输出

2. **新增RESTART-XON子选项**
   - RFC 1080：隐含使用此行为，但未明确定义
   - RFC 1372：明确定义为独立的子选项

3. **更完善的协议规范**
   - RFC 1080：协议定义相对简单
   - RFC 1372：提供更详细的命令语义和交互流程

4. **更好的互操作性**
   - RFC 1080：某些边界情况处理不明确
   - RFC 1372：明确定义各种场景下的行为

### 向后兼容性

RFC 1372在设计时充分考虑了与RFC 1080的兼容性：

1. **选项代码不变**：继续使用代码33，确保基本协商机制兼容

2. **保留原有命令**：OFF（0）和ON（1）命令保持不变

3. **扩展而非替换**：新增的RESTART-ANY（2）和RESTART-XON（3）是扩展功能

4. **优雅降级**：不支持新子选项的实现可以忽略它们，继续使用基本功能

## 实现要求

### 客户端实现

实现RFC 1372的Telnet客户端需要：

1. **选项协商支持**
   - 正确响应WILL/DO/WONT/DONT协商
   - 维护协商状态

2. **子选项处理**
   - 解析所有四种子选项命令（OFF、ON、RESTART-ANY、RESTART-XON）
   - 正确处理未知的子选项代码

3. **流控制管理**
   - 根据OFF/ON命令启用或禁用流控制
   - 实现RESTART-ANY模式的字符消耗机制
   - 实现RESTART-XON模式的严格XON恢复机制

4. **状态维护**
   - 跟踪当前流控制状态（启用/禁用）
   - 跟踪当前恢复模式（ANY/XON）
   - 跟踪输出暂停状态

5. **用户界面**
   - 可选：提供配置选项让用户选择默认行为
   - 可选：显示当前流控制状态

### 服务器端实现

实现RFC 1372的Telnet服务器需要：

1. **选项协商管理**
   - 发起或响应TOGGLE-FLOW-CONTROL选项协商
   - 跟踪每个连接的协商状态

2. **应用程序接口**
   - 提供API让应用程序请求改变流控制状态
   - 提供API让应用程序选择恢复模式（RESTART-ANY或RESTART-XON）

3. **命令发送**
   - 根据应用程序请求发送相应的子选项命令
   - 确保命令序列的正确性

4. **兼容性处理**
   - 检测客户端是否支持该选项
   - 对不支持的客户端提供降级方案

## 应用场景

### 文本编辑器

RFC 1372最典型的应用场景仍然是文本编辑器，但提供了更灵活的控制：

**Emacs编辑器**：
```
1. 用户启动Emacs
2. 服务器发送: IAC SB TOGGLE-FLOW-CONTROL OFF IAC SE
3. 用户可以使用Control-S进行搜索
4. 用户退出Emacs
5. 服务器发送: IAC SB TOGGLE-FLOW-CONTROL ON IAC SE
6. 服务器发送: IAC SB TOGGLE-FLOW-CONTROL RESTART-ANY IAC SE
7. 流控制恢复，但使用更友好的任意键恢复模式
```

### 交互式应用程序

对于需要良好用户体验的交互式应用：

**使用RESTART-ANY模式**：
```
1. 应用启动时设置RESTART-ANY模式
2. 用户意外按下Control-S导致输出暂停
3. 用户按任意键即可恢复，无需记住Control-Q
4. 提供更直观的用户体验
```

### 批量数据查看

对于需要查看大量输出的场景：

**使用RESTART-XON模式**：
```
1. 用户执行产生大量输出的命令（如日志查看）
2. 设置RESTART-XON模式确保严格的流控制
3. 用户按Control-S暂停输出仔细查看
4. 用户可以输入命令或文本，不会意外恢复输出
5. 用户准备好后按Control-Q继续
```

### 脚本和自动化

在自动化脚本中：

**禁用流控制**：
```
1. 脚本开始执行前禁用流控制
2. 避免脚本输出中的Control-S/Control-Q字符干扰
3. 确保脚本可靠执行
```

## 技术优势

### RESTART-ANY的优势

1. **改善用户体验**
   - 用户无需记住特定的恢复键
   - 任意按键即可恢复，更加直观
   - 减少因不知道如何恢复而导致的困惑和支持请求

2. **降低学习成本**
   - 新用户不需要学习XON/XOFF协议
   - 减少用户培训需求
   - 更符合现代用户的使用习惯

3. **快速恢复**
   - 用户可以立即按任意键恢复
   - 不需要寻找特定的控制键
   - 提高工作效率

### RESTART-XON的优势

1. **严格的协议遵从**
   - 完全符合传统XON/XOFF流控制标准
   - 与遗留系统和设备兼容
   - 满足需要精确流控制的应用需求

2. **不丢失字符**
   - 在暂停期间输入的字符会被保留
   - 应用程序可以接收所有用户输入
   - 适合需要精确输入的场景

3. **可预测的行为**
   - 行为明确，不会产生歧义
   - 便于调试和故障排除
   - 适合关键任务应用

### 灵活性和可配置性

RFC 1372的最大优势在于提供了灵活的选择：

1. **应用程序可以选择最适合的模式**
   - 交互式应用选择RESTART-ANY提供更好的用户体验
   - 精确控制应用选择RESTART-XON确保数据完整性
   - 特殊应用可以完全禁用流控制

2. **动态切换**
   - 可以在会话期间动态改变流控制模式
   - 根据不同的应用阶段选择不同的策略
   - 提供最大的灵活性

3. **向后兼容**
   - 与RFC 1080完全兼容
   - 不支持新功能的客户端可以继续使用基本功能
   - 平滑的升级路径

## 实际部署

### Unix系统实现

RFC 1372在Unix系统中得到了广泛实现：

**BSD系统**：
- BSD 4.4及后续版本的telnetd实现了RFC 1372
- 提供完整的RESTART-ANY和RESTART-XON支持
- 成为Unix系统的标准功能

**Linux系统**：
- GNU inetutils中的Telnet实现
- netkit-telnet包
- 各种Linux发行版的默认Telnet服务器

**商业Unix系统**：
- Sun Solaris
- HP-UX
- IBM AIX
- SGI IRIX

### 终端仿真器支持

许多终端仿真器实现了RFC 1372支持：

**xterm**：
- X Window系统的标准终端仿真器
- 支持完整的RFC 1372功能
- 可通过配置选择流控制模式

**PuTTY**：
- Windows平台流行的SSH/Telnet客户端
- 提供流控制配置选项
- 支持RESTART-ANY和RESTART-XON模式

**其他终端仿真器**：
- GNOME Terminal
- Konsole
- iTerm2（macOS）
- Windows Terminal

### 网络设备

一些网络设备的管理接口也实现了RFC 1372：

- 路由器和交换机的Telnet管理接口
- 串口服务器（Serial Console Server）
- 终端服务器（Terminal Server）
- KVM over IP设备

## 实现考虑

### RESTART-ANY的实现细节

实现RESTART-ANY模式时需要注意：

1. **字符消耗机制**
   - 用于恢复输出的字符必须被"消耗"，不传递给应用程序
   - 只有第一个恢复字符被消耗，后续字符正常传递
   - XOFF字符不能用于恢复输出

2. **状态管理**
   - 需要维护"输出暂停"状态标志
   - 在暂停状态下，第一个非XOFF字符触发恢复
   - 恢复后立即清除暂停状态

3. **边界情况处理**
   - 如果在暂停期间收到多个字符，只消耗第一个
   - 如果恢复字符是IAC，需要特殊处理
   - 需要正确处理Telnet协议的转义序列

### RESTART-XON的实现细节

实现RESTART-XON模式时需要注意：

1. **严格的XON检测**
   - 只有XON字符（ASCII 17，Control-Q）可以恢复输出
   - 其他所有字符都正常传递给应用程序
   - XON字符本身也会被传递（不被消耗）

2. **字符传递**
   - 在暂停期间，所有非XON字符正常排队
   - XON字符触发恢复，但也进入数据流
   - 确保应用程序接收所有字符

3. **与RESTART-ANY的区别**
   - RESTART-ANY消耗恢复字符
   - RESTART-XON不消耗XON字符
   - 这是两种模式的关键区别

### 模式切换

在会话期间切换模式时需要注意：

1. **状态一致性**
   - 切换模式前确保当前状态清晰
   - 如果输出正在暂停，切换模式可能导致混淆
   - 建议在非暂停状态下切换模式

2. **命令顺序**
   - 先发送ON命令启用流控制
   - 再发送RESTART-ANY或RESTART-XON设置恢复模式
   - 确保客户端正确理解命令序列

3. **默认模式**
   - 如果只发送ON命令而不指定恢复模式
   - 客户端应使用默认行为（通常是RESTART-XON）
   - 建议明确指定恢复模式以避免歧义

## 安全考虑

### 与RFC 1080相同的安全问题

RFC 1372继承了RFC 1080的所有安全考虑：

1. **明文传输**
   - 流控制命令以明文传输
   - 可能被中间人攻击者拦截或篡改
   - 与Telnet协议本身的安全问题相同

2. **未授权控制**
   - 攻击者可能发送恶意的流控制命令
   - 可能导致终端行为异常
   - 影响用户体验和系统可用性

### RESTART-ANY的潜在风险

RESTART-ANY模式引入了一个新的考虑因素：

1. **字符丢失**
   - 用于恢复的字符会被消耗
   - 如果用户不知道这一点，可能感到困惑
   - 在某些场景下可能导致意外的数据丢失

2. **不可预测的恢复**
   - 任意字符都可以恢复输出
   - 用户可能意外恢复输出
   - 需要用户了解当前的流控制模式

### 安全建议

1. **使用SSH替代Telnet**
   - SSH提供加密和认证
   - 保护流控制命令不被篡改
   - 这是最根本的安全解决方案

2. **限制网络访问**
   - 仅在可信网络中使用Telnet
   - 使用防火墙限制Telnet访问
   - 考虑使用VPN保护Telnet流量

3. **用户教育**
   - 告知用户不同流控制模式的行为
   - 说明RESTART-ANY会消耗恢复字符
   - 提供清晰的文档和帮助信息

## 历史意义

### 协议演进的典范

RFC 1372展示了互联网协议演进的良好实践：

1. **基于实际需求的改进**
   - 根据RFC 1080的实际使用经验进行改进
   - 解决用户反馈的实际问题
   - 增加实用的新功能

2. **保持向后兼容**
   - 不破坏现有实现
   - 提供平滑的升级路径
   - 允许新旧系统共存

3. **渐进式扩展**
   - 通过添加新子选项扩展功能
   - 不改变基本协议结构
   - 保持协议的简洁性

### 用户体验的重视

RFC 1372体现了对用户体验的重视：

1. **RESTART-ANY的人性化设计**
   - 降低用户学习成本
   - 提供更直观的操作方式
   - 减少用户困惑和支持请求

2. **灵活性与选择**
   - 不强制使用单一模式
   - 允许应用程序根据需求选择
   - 平衡易用性和精确控制

3. **实用主义**
   - 解决实际问题而非理论问题
   - 基于真实使用场景设计
   - 注重实际部署效果

## 现代视角

### Telnet的现状

与RFC 1080一样，RFC 1372的实际应用随着Telnet的衰落而减少：

1. **SSH的普及**
   - SSH提供加密和更强的安全性
   - 逐渐取代Telnet成为远程登录标准
   - 大多数现代系统默认使用SSH

2. **遗留系统支持**
   - 嵌入式设备管理接口
   - 网络设备配置
   - 串口服务器
   - 教学和实验环境

### 设计理念的持续价值

尽管RFC 1372的直接应用减少，但其设计理念仍有参考价值：

1. **用户体验优先**
   - RESTART-ANY体现的易用性思考
   - 在技术实现和用户友好之间取得平衡
   - 这种思维方式在现代软件设计中仍然重要

2. **灵活性设计**
   - 提供多种选项而非单一方案
   - 允许根据场景选择合适的模式
   - 现代API设计中的常见模式

3. **向后兼容的扩展**
   - 如何在不破坏现有系统的情况下添加新功能
   - 协议版本管理的良好实践
   - 对现代软件工程仍有启发

### 流控制的现代替代方案

在现代终端和应用中，流控制问题有了新的解决方案：

1. **硬件性能提升**
   - 现代计算机处理速度远超数据传输速度
   - 缓冲区容量大幅增加
   - 流控制的必要性降低

2. **更好的终端仿真**
   - 现代终端仿真器有更智能的缓冲管理
   - 支持滚动回看功能
   - 提供更好的用户界面控制

3. **应用层解决方案**
   - 分页显示（如less、more命令）
   - 应用内置的输出控制
   - 图形界面的滚动条和搜索功能

## 相关技术

### 其他Telnet流控制相关选项

除了RFC 1372，还有其他与流控制相关的Telnet选项：

- **RFC 856**：Binary Transmission，二进制传输选项
- **RFC 857**：Echo选项，控制字符回显
- **RFC 858**：Suppress Go-Ahead选项
- **RFC 1184**：Linemode选项，提供更高级的行编辑功能

### 串口通信中的流控制

RFC 1372处理的软件流控制概念源自串口通信：

1. **RS-232标准**
   - 定义了串口通信的物理和电气特性
   - 包括硬件流控制信号（RTS/CTS、DTR/DSR）
   - 软件流控制（XON/XOFF）作为替代方案

2. **现代串口应用**
   - 嵌入式系统调试
   - 工业控制设备
   - 网络设备控制台
   - GPS和传感器通信

### SSH中的流控制

虽然SSH取代了Telnet，但流控制概念仍然相关：

1. **SSH的流控制机制**
   - SSH使用窗口大小机制进行流控制
   - 基于TCP的流控制
   - 不依赖XON/XOFF字符

2. **终端模式**
   - SSH支持多种终端模式
   - 可以透明传输Control-S和Control-Q
   - 应用程序可以正常使用这些字符

## 总结

RFC 1372作为RFC 1080的扩展和改进版本，成功解决了Telnet远程流控制中的用户体验问题。通过引入RESTART-ANY和RESTART-XON两个新的子选项，该协议提供了更灵活的流控制恢复机制，既满足了易用性需求，又保持了对精确控制的支持。

**RFC 1372的主要贡献**：

1. **RESTART-ANY子选项**：允许使用任意字符恢复输出，显著改善了用户体验，降低了学习成本

2. **RESTART-XON子选项**：明确定义了严格的XON恢复模式，满足需要精确流控制的应用需求

3. **向后兼容性**：完全兼容RFC 1080，提供平滑的升级路径

4. **灵活性**：允许应用程序根据自身需求选择最合适的流控制模式

**协议设计的启示**：

RFC 1372展示了优秀的协议设计原则：
- 基于实际使用经验进行迭代改进
- 在易用性和功能性之间取得平衡
- 保持向后兼容性和简洁性
- 关注用户体验和实际需求

**现代意义**：

虽然随着SSH的普及，Telnet及RFC 1372的直接应用场景已经减少，但该协议在互联网发展史上仍具有重要意义。它展示了如何通过协议扩展机制解决实际问题，体现了互联网标准制定过程中的渐进式改进和用户中心设计原则。

对于网络工程师、协议设计者和软件开发者而言，RFC 1372仍然是一个值得研究的经典案例，展示了如何在现有协议框架内优雅地扩展功能，如何平衡技术实现与用户体验，以及如何确保新旧系统的兼容性。

## 参考资料

- RFC 854: Telnet Protocol Specification
- RFC 1080: Telnet Remote Flow Control Option
- RFC 1372: Telnet Remote Flow Control Option (本文档)
- RFC 856: Telnet Binary Transmission
- RFC 857: Telnet Echo Option
- RFC 858: Telnet Suppress Go Ahead Option
- RFC 1184: Telnet Linemode Option
- IANA Telnet Options Registry

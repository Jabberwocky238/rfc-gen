---
description: RFC 1187 - 使用SNMP进行批量表检索，由M. Rose、K. McCloghrie和J. Davin于1990年10月发布，介绍了一系列用于通过SNMP高效检索大型MIB表的算法，包括流水线算法和并行算法，通过多线程和自适应超时机制显著提高了表检索性能
keywords:
  - RFC1187
  - SNMP
  - 批量表检索
  - Bulk Table Retrieval
  - get-next操作符
  - 流水线算法
  - Pipelined Algorithm
  - 并行算法
  - Parallel Algorithm
  - 网络管理
  - MIB表
  - 多线程
  - 自适应超时
  - 性能优化
  - 表遍历
  - OID
  - 对象标识符
  - 管理站
  - SNMP代理
properties:
  rfc_number: 1187
  title: "Bulk Table Retrieval with the SNMP"
  authors:
    - name: "M. Rose"
      organization: "Performance Systems International, Inc."
    - name: "K. McCloghrie"
      organization: "Hughes LAN Systems"
    - name: "J. Davin"
      organization: "MIT Laboratory for Computer Science"
  publication_date: "1990-10"
  status: "实验性协议"
  category: "SNMP性能优化"
  related_rfc:
    - "RFC 1157"
---
# RFC 1187 - 使用SNMP进行批量表检索

## 文档概述

RFC 1187是由Performance Systems International的Marshall T. Rose、Hughes LAN Systems的Keith McCloghrie和MIT计算机科学实验室的James R. Davin于1990年10月联合发布的实验性协议文档，标题为"Bulk Table Retrieval with the SNMP"（使用SNMP进行批量表检索）。

该文档报告了一系列有趣的算法，用于通过简单网络管理协议（SNMP）进行批量表检索。文档的核心贡献是证明了SNMP的强大get-next操作符可以通过巧妙的算法设计实现高效的批量表检索，而无需修改SNMP协议本身或给代理增加显著负担。

RFC 1187介绍了两种主要算法：
1. **流水线算法（Pipelined Algorithm）**：采用多线程方法，通过保持多个事务在传输中来提高检索效率
2. **并行算法（Parallel Algorithm）**：将多个线程映射到单个SNMP操作中，进一步优化性能

## 历史背景

### SNMP的发展

在1990年RFC 1187发布时，SNMP（RFC 1157）已经成为互联网网络管理的标准协议。SNMP提供了一种简单而强大的机制来监控和管理网络设备，其核心操作包括get、set和get-next。

### 批量表检索的挑战

网络管理中的一个常见任务是从SNMP代理检索大型MIB（管理信息库）表，例如路由表、接口表等。使用传统的串行方法，检索大型表可能非常耗时，这引发了对SNMP批量检索能力的质疑。

### 设计动机

RFC 1187的主要设计动机是：
1. **证明SNMP的能力**：反驳SNMP无法高效进行批量表检索的观点
2. **无需协议修改**：通过管理站的智能算法实现性能提升，而不修改SNMP协议
3. **自适应性**：算法能够适应不同的网络条件和代理负载
4. **实用性**：提供可实际部署的解决方案

## SNMP批量表检索基础

### get-next操作符

SNMP的get-next操作符是表遍历的核心工具。它接受一个或多个对象标识符（OID）作为操作数，返回字典序中下一个对象的值。

### 串行检索方法

**最简单的方法**：每次检索一个对象

示例：遍历ipRoutingTable
```
get-next (ipRouteDest)
→ 返回 ipRouteDest.0.0.0.0

get-next (ipRouteDest.0.0.0.0)
→ 继续检索下一个对象

get-next (ipRouteDest.192.33.4.0)
→ 返回 ipRouteIfIndex.0.0.0.0 (下一列)

get-next (ipRouteMask.192.33.4.0)
→ 返回 ipNetToMediaIfIndex.192.33.4.1 (表外)
```

这种方法需要 **O(行数 × 列数)** 次管理操作。

### 改进的串行方法

**按行检索**：每次检索整行

```
get-next (ipRouteDest, ipRouteIfIndex, ..., ipRouteMask)
→ 返回整行：
  ipRouteDest.0.0.0.0
  ipRouteIfIndex.0.0.0.0
  ipRouteMask.0.0.0.0
```

使用前一次操作的结果作为下一次操作的操作数，继续检索。

这种方法需要 **O(行数)** 次管理操作。

### 串行方法的局限

有人认为O(行数)次串行操作是SNMP的弱点，因为串行操作耗时较长。然而，这种论点的问题在于对"串行"一词的隐含强调。

### 并行化的可能性

实际上，没有任何东西阻止聪明的管理站多次调用get-next操作，每次使用不同的操作数，以实现网络中的并行性和流水线处理。

**关键优势**：
- 不需要修改SNMP协议
- 不会给代理增加显著负担
- 完全由管理站控制

## 流水线算法

### 算法概述

流水线算法采用多线程方法来检索表数据。为简洁起见，算法描述仅检索表的单列；但不失一般性，可以轻松扩展到检索所有列。

**核心思想**：
- 每个线程生成自己的get-next请求流并处理相应的响应流
- 对于给定线程，一个请求对应表中的不同行
- 通过保持多个事务在传输中来提高整体检索效率
- 代理和管理站可以同时处理事务

### 自适应机制

算法通过两种方式适应不同的网络条件、拓扑和代理负载：

1. **动态调整活动线程数**：即正在处理和传输中的事务数量
2. **动态调整重传超时**：基于事务往返时间和丢失/超时情况

### 最大活动线程数

**动态确定的必要性**：

- **只有一个线程**：退化为前面提到的串行算法
- **线程过多**：可能超载代理，导致代理丢弃请求，造成浪费
- **理想数量**：恰好使下一个请求在代理完成处理前一个请求时到达

**影响因素**：
- 往返时间（RTT）
- 网络拓扑和流量负载
- 不同表可能需要不同的线程数

**动态估算方法**：
- 计算：往返时间 ÷ 活动线程数
- 当此值达到新的最小值时，调整线程数限制
- 设置为发送相应请求时的活动线程数（加1以允许请求丢失）

### 重传机制

**当前策略**：
- 重传决策仅基于超时

**可能的优化**：
- 管理器记住请求发送顺序
- 将顺序与传入响应关联
- 如果后发送的线程先收到响应，假设发生丢失
- 立即进行重传

**前提条件**：
- 在管理器和代理之间没有网关时
- 请求和响应按序到达的可能性很高

### 基本定义

**线程（Thread）**：

管理站中保存的状态信息，对应要检索的表的一部分。每个线程包含：

1. **请求ID范围**：此线程可以使用的SNMP请求ID范围，以及最后使用的请求ID
2. **最后发送的消息**：最后发送的SNMP消息、已发送次数、发送时间
3. **OID边界**：
   - 包含下界（inclusive lower-bound）
   - 排除上界（exclusive upper-bound）
   - 当前使用的对象实例
4. **活动线程数**：最后发送时的活动线程数

**线程创建**：
- 创建时自动使用其包含下界OID发送get-next消息
- 被放置在"线程队列"的末尾

**OID表示**：

对象标识符（OID）的具体表示包含两部分：
1. **nelem**：存在的子标识符数量
2. **elems**：子标识符数组，索引从1到nelem（包含）

### 顶层算法

**初始化**：
- 启动三个线程
- 初始分区位置：column、column.127、column.192
- 这些位置针对以IP地址索引的表进行了优化
- 但算法适用于任何表格对象

**主循环**：
```
pipelined_algorithm (column)
{
    timeout = 初始值;

    启动新线程 [column, column.127);
    启动新线程 [column.127, column.192);
    启动新线程 [column.192, column+1);

    while (存在线程) {
        等待事件;
        foreach (有传入消息的线程，按线程队列顺序检查) {
            if (消息的OID >= 线程的上界) {
                销毁线程;
                continue;
            }

            存储消息中的变量绑定;

            if (同时线程数未超过最大值
                && NOT backoff
                && (a = oid_median(消息OID, 线程上界))) {
                启动新线程 [a, 线程上界);
                线程上界 = a;
                将线程放到队列末尾;
                backoff = TRUE;
            }
            为线程执行另一个get-next;
        }
    }
}
```

**处理逻辑**：
1. 检查响应的OID是否超出线程范围
2. 如果超出，表示该线程对应的表部分已完全检索，销毁线程
3. 否则，存储变量绑定
4. 如果应该创建新线程，则相应地分割表的部分
5. 无论如何，代表线程发出另一个get-next操作

### 等待事件

**事件等待过程**：

等待事件包括等待少量时间或直到至少收到一条消息。

**消息处理**：
1. 将遇到的任何消息与相应的线程关联
2. 测量请求/响应的最大往返时间
3. 计算最大活动线程数

**超时调整**：
- 如果未收到响应：超时加倍
- 如果收到响应：
  - 计算超时调整值 = 1.5 × 最大观察到的往返时间
  - 如果调整值 > 当前超时：设置为调整值
  - 否则：当前超时与调整值取平均

**重传处理**：
- 如果至少一个线程未收到响应
- 识别等待时间最长的线程
- 如果经过时间（加噪声因子）> 当前超时值
- 尝试另一次重传

### OID中值查找

**问题背景**：

对象标识符空间既不均匀也不连续。因此，并不总是能够选择一个在两个任意对象标识符之间的字典序OID。流水线算法会尽最大努力尝试。

**算法逻辑**：

从头开始扫描两个OID的每个子标识符，直到遇到差异。此时有几种可能的情况：

1. **上界OID用完子标识符**：
   - 两个OID相同，或下界OID大于上界OID（接口错误）
   - 不返回OID

2. **下界OID用完子标识符**：
   - 从上界OID定位第一个后续非零子标识符
   - 如果找不到，则两个OID之间不存在OID，不返回
   - 否则，复制上界OID但在此非零子标识符处截断
   - 将该子标识符减半，返回结果OID

3. **其他情况**：
   - 复制下界OID但在差异点截断
   - 将最后一个子标识符设置为差异的算术平均值
   - 如果差异仅为1（最后子标识符保持不变）
   - 添加新的子标识符，注意要大于下界OID中可能存在的子标识符
   - 返回结果OID

### 流水线算法的实践经验

**实现状态**：
- 流水线算法已经实现并进行了一些实验
- 目前提供广泛的性能数据还为时过早
- 算法仍在调优中，仅在原型环境中实现

**性能数据**：
- 表大小：O(2500)行
- 流水线算法性能：**121条目/秒**
- 串行算法性能：**56条目/秒**
- 性能提升：**216%**

### 超时值的动态范围

**当前方法的局限**：

流水线算法对超时值采用简单方法，不维护值的历史记录并据此采取行动。

**潜在问题**：

1. **超时达到最大值并锁定**：
   - 表明资源（网络或代理）饱和
   - 理想方案：合并两个线程
   - 问题：做出此决定时可能不存在两个连续线程
   - 替代方案：延迟准备发出新get-next操作的线程的传输

2. **超时降至最小值并锁定**：
   - 应该启动更多线程

### 不正确的代理实现

**发现的问题**：

许多代理没有正确实现强大的get-next操作符。特别是，当get-next请求包含带有任意生成后缀的操作数时，某些代理实现会不正确处理，最终返回字典序小于操作数的结果！

**典型原因**：

当列对象的实例标识符由MAC或IP地址形成时，地址的每个八位字节形成实例标识符的一个子标识符。在这种情况下，不正确的代理实现仅比较操作数中子标识符的最低有效八位字节，而不是子标识符的完整值。

**处理方式**：

遇到这种交互时，流水线算法实现声明线程死亡（注意表中可能存在间隙），然后继续。

## 并行算法

### 两步优化方法

一个有趣的优化是将问题分为两步：

**第一步**：
- 遍历表的一列以确定表中有意义的实例标识符的完整范围
- 虽然上述描述中流水线算法检索单列，但原型实现可以检索多列

**第二步**：
- 使用SNMP get操作检索其他列
- 因为实例标识符已知，可以直接使用get操作
- 管理器可以动态确定单个SNMP get操作中可以放置多少变量
- 最小化请求数量

**优势**：
- 代理执行get操作通常比执行get-next操作成本更低
- 当请求多列时，这个两步过程在代理上需要更少的执行时间

### 并行算法概念

**核心思想**：

目前，每个线程映射到单个SNMP操作。一个强大的洞察是建议将多个线程映射到单个SNMP操作：管理器必须动态确定单个强大的get-next操作中可以放置多少变量。

**优势与代价**：
- 优势：减少流量
- 代价：要求代理为每个请求使用更多资源

### 算法关系

**退化情况**：
- 串行检索可以看作流水线算法的退化情况，其中活动线程数为1
- 流水线算法是并行算法的特殊情况，其中每个SNMP操作的线程数为1

### 并行算法的实践经验

**实现状态**：
- 并行算法已经实现并进行了一些实验
- 目前提供广泛的性能数据还为时过早
- 算法仍在调优中，仅在原型环境中实现

**性能数据**：
- 表大小：O(2500)行
- 并行算法性能：**320条目/秒**
- 串行算法性能：**56条目/秒**
- 性能提升：**571%**

**性能对比总结**：
- 串行算法：56条目/秒（基准）
- 流水线算法：121条目/秒（提升216%）
- 并行算法：320条目/秒（提升571%）

## 技术意义与影响

### 证明SNMP的能力

RFC 1187的最重要贡献是证明了SNMP的get-next操作符可以通过智能算法实现高效的批量表检索。这反驳了SNMP在大规模数据检索方面能力不足的批评。

### 无需协议修改

算法的优雅之处在于：
- 不需要修改SNMP协议
- 不需要修改SNMP代理
- 完全由管理站实现
- 向后兼容所有现有SNMP实现

### 自适应性设计

算法的自适应特性使其能够：
- 适应不同的网络拓扑
- 适应变化的网络负载
- 适应不同的代理性能
- 动态优化性能参数

### 受TCP启发的设计

RFC 1187明确指出，流水线算法中的许多思想受到Van Jacobson在TCP自适应定时器方面工作的启发。这展示了跨协议层的设计理念可以相互借鉴。

**TCP概念的应用**：
- 自适应超时机制
- 往返时间测量
- 拥塞控制思想
- 滑动窗口概念

### 实际应用价值

**网络管理场景**：
1. **大型路由表检索**：ISP和企业网络中的路由器可能有数千条路由
2. **接口统计收集**：大型交换机可能有数百个接口
3. **ARP表监控**：大型网络的ARP表可能非常庞大
4. **性能监控**：需要定期收集大量性能数据

**实际部署考虑**：
- 减少管理站的等待时间
- 提高网络管理效率
- 降低网络带宽消耗
- 改善用户体验

## 算法的局限性与挑战

### 实现复杂性

**流水线算法的复杂性**：
- 需要维护多个线程状态
- 需要实现复杂的超时和重传逻辑
- 需要处理OID中值计算
- 需要动态调整参数

**并行算法的额外复杂性**：
- 需要动态确定每个操作的变量数
- 需要平衡流量减少与代理负载
- 需要更复杂的线程管理

### 代理实现问题

RFC 1187发现许多代理实现存在get-next操作符的错误实现，这限制了算法的实际应用效果。这凸显了协议实现质量的重要性。

### 超时管理的挑战

文档承认当前的超时管理方法相对简单，在某些极端情况下（如超时值锁定在最大或最小值）可能不够优化。

## 现代视角

### SNMP的演进

自1990年以来，SNMP经历了多个版本的演进：
- **SNMPv2**：引入了GetBulk操作，专门用于批量检索
- **SNMPv3**：增加了安全性和管理功能
- **现代实现**：许多网络管理系统已经内置了高效的批量检索机制

### GetBulk操作的出现

RFC 1187的工作直接影响了SNMPv2中GetBulk操作的设计。GetBulk操作在协议层面提供了批量检索支持，简化了管理站的实现。

### 算法思想的持久价值

尽管有了GetBulk操作，RFC 1187的算法思想仍然有价值：
- **自适应机制**：动态调整参数以适应网络条件
- **并行处理**：利用网络并行性提高效率
- **流水线技术**：保持多个事务在传输中
- **性能优化**：在不修改协议的情况下提升性能

### 对其他协议的影响

RFC 1187展示的优化技术不仅适用于SNMP，其核心思想也影响了其他网络管理和数据检索协议的设计。

## 致谢

RFC 1187明确致谢了以下贡献：

**Van Jacobson**：
- 流水线算法中的许多思想受到他在TCP自适应定时器方面工作的启发
- 他的研究为网络协议的性能优化提供了重要的理论基础

**Jeffrey D. Case**：
- 最初提出了并行化修改的建议
- 为算法的进一步优化提供了关键思路

**Frank Kastenholz (Racal-Interlan)**：
- 提供了宝贵的评论和反馈

## 安全考虑

RFC 1187在"Security Considerations"部分简要说明：本备忘录不讨论安全问题。

这反映了1990年代早期网络协议设计中对安全性的关注程度。批量表检索算法本身不引入新的安全问题，但继承了SNMP协议的所有安全特性和局限性。

**现代安全视角**：
- SNMPv1和SNMPv2c使用明文社区字符串，存在安全风险
- SNMPv3引入了基于用户的安全模型（USM）
- 批量检索可能增加拒绝服务攻击的风险
- 需要适当的访问控制和速率限制

## 总结

RFC 1187作为SNMP批量表检索的开创性工作，成功地证明了SNMP的get-next操作符可以通过智能算法实现高效的大规模数据检索。文档介绍的流水线算法和并行算法展示了如何在不修改协议的情况下，通过管理站的智能实现显著提升性能。

**核心贡献**：

1. **证明SNMP能力**：反驳了SNMP无法高效进行批量检索的批评
2. **流水线算法**：通过多线程和自适应机制实现216%的性能提升
3. **并行算法**：通过将多个线程映射到单个操作实现571%的性能提升
4. **自适应设计**：算法能够动态适应网络条件和代理负载
5. **向后兼容**：完全由管理站实现，不需要修改协议或代理

**技术影响**：

RFC 1187的工作对后续SNMP发展产生了深远影响：
- 直接启发了SNMPv2中GetBulk操作的设计
- 展示了协议优化可以在应用层实现
- 证明了自适应算法在网络管理中的价值
- 为其他批量数据检索协议提供了设计参考

**实践价值**：

虽然文档发布于1990年，其核心思想在今天仍然具有实践价值：
- 多线程并发处理的思想
- 自适应超时和流量控制机制
- 流水线技术的应用
- 性能优化的系统方法

RFC 1187展示了如何通过深入理解协议特性和巧妙的算法设计，在不修改底层协议的情况下实现显著的性能提升。这种方法论对于网络协议的优化和实现具有普遍的指导意义。

## 参考资料

1. Case, J., Fedor, M., Schoffstall, M., and J. Davin, "Simple Network Management Protocol (SNMP)", RFC 1157, SNMP Research, Performance Systems International, Performance Systems International, MIT Laboratory for Computer Science, May 1990.

2. Jacobson, V., "Congestion Avoidance and Control", ACM SIGCOMM '88, August 1988.

3. RFC 1905: Protocol Operations for Version 2 of the Simple Network Management Protocol (SNMPv2) - 引入了GetBulk操作

4. RFC 3416: Version 2 of the Protocol Operations for the Simple Network Management Protocol (SNMP)
